#' @name MBCSec
#'
#' @title Multivariate Box-Cox Symmetric Class of Distributions Generating
#'     by Elliptical Copula
#'
#' @description These functions provide the joint probability density function
#'     and a random generator for the multivariate Box-Cox symmetric class of
#'     distributions generated by elliptical copulas.
#'
#' @param x vector or matrix of non-negative quantiles. If \code{x} is a matrix,
#'     each row is taken to be a quantile.
#' @param n number of random values to return.
#' @param d dimension of the data to be generated. Argument used only in
#'     \code{rmbcsec()}.
#' @param param a list that has as components the vectors of marginal
#'     parameters \code{mu}, \code{sigma}, \code{lambda}, and \code{nu}. In case
#'     the marginal distribution is not indexed by \code{nu}, it receives
#'     \code{NULL} by default.
#' @param P association matrix. If it is specified with \code{NULL} (default),
#'     then the identity matrix is used.
#' @param df degrees of freedom associated with the t copula.
#' @param copula character; informs which distribution in the class of
#'     elliptical distributions should be used to generate the elliptical
#'     copula. Currently, the copulas available are:
#'     Gaussian (\code{"gaussian"}), Student's t (\code{"st"}), Cauchy
#'     (\code{"cauchy"}), and double exponential (\code{"dexponential"}).
#' @param gen a character or a vector character; specifies the distributions
#'     generating the marginal BCS distributions. If all BCS margins are
#'     generated by the same generating density, it is sufficient to enter only
#'     one character. A table with the current available generating
#'     distributions for the BCS class can be seen in \code{\link{BCSgen}}.
#'
#' @return \code{dmbcsec} returns the joint density function and \code{rmbcsec}
#'     generates random observations.
#'
#' @references
#'  Cole, T., & Green, P.J. (1992). Smoothing reference centile curves: the LMS
#'      method and penalized likelihood. Stat. Med, 11, 1305--1319.
#'
#'  Ferrari, S. L., & Fumes, G. (2017). Box-Cox symmetric distributions and
#'      applications to nutritional data. AStA Advances in Statistical Analysis,
#'      101, 321--344.
#'
#'  Rigby, R. A., & Stasinopoulos, D. M. (2004). Smooth centile curves for skew
#'      and kurtotic data modelled using the Box-Cox power exponential
#'      distribution. Statistics in medicine, 23, 3053--3076.
#'
#'  Rigby, R. A., & Stasinopoulos, D. M. (2006). Using the Box-Cox t
#'      distribution in GAMLSS to model skewness and kurtosis. Statistical
#'      Modelling, 6, 209-229.
#'
#'  Vanegas, L. H., & Paula, G. A. (2016). Log-symmetric distributions:
#'      statistical properties and parameter estimation. Brazilian Journal of
#'      Probability and Statistics, 30, 196--220.
#'
#' @author Rodrigo M. R. Medeiros <\email{rodrigo.matheus@live.com}>
#'

# Joint density
#' @rdname MBCSec
#' @export
dmbcsec <- function(x, param, P = NULL, df = 4,
                    copula = c("gaussian", "st", "cauchy", "dexponential"),
                    gen = "NO"){

  ### Reading the copula generating density
  copula <- match.arg(copula, c("gaussian", "st", "cauchy", "dexponential"))

  ### Setting dimensions
  if (is.vector(x))
    x <- matrix(x, ncol = length(x))

  n <- dim(x)[1]
  d <- dim(x)[2]

  ### Default association matrix
  if (is.null(P)) P <- diag(d)

  ### Marginal parameters
  mu <- param$mu
  sigma <- param$sigma
  lambda <- param$lambda
  nu <- param$nu

  ### Copula density argument
  if (length(gen) == 1){
    w <- pBCS(x, mu, sigma, lambda, nu, gen[1])
  }else{
    w <- matrix(apply(matrix(gen, ncol = 1), 1,
           function(gen) pBCS(x, mu, sigma, lambda, nu, gen))[, 1], ncol = 2)
  }

  if (copula != "st"){
    q <- BCSgen(ell(copula)$gen)$q(w)
    den <- log(ell(copula)$Md(q, P)) +
      apply(matrix(
        apply(matrix(gen, ncol = 1), 1,
        function(gen) log(dBCS(x, mu, sigma, lambda, nu, gen)))[, 1], ncol = d
        ), 1, sum) -
      apply(matrix(log(BCSgen(ell(copula)$gen)$d(q^2)), ncol = d), 1, sum)

      #mvtnorm::dmvnorm(q, sigma = P, log = TRUE) +
      #apply(matrix(log(dBCS(x, mu, sigma, lambda, nu, gen[1])), ncol = d), 1, sum) -
      #apply(matrix(log(stats::dnorm(q)), ncol = d), 1, sum)
  } else {
    q <- BCSgen(ell(copula)$gen)$q(w, df)
    den <- log(ell(copula)$Md(q, P, df)) +
      apply(matrix(
        apply(matrix(gen, ncol = 1), 1,
        function(gen) log(dBCS(x, mu, sigma, lambda, nu, gen)))[, 1], ncol = d
        ), 1, sum) -
      apply(matrix(log(BCSgen(ell(copula)$gen)$d(q^2, df)), ncol = d), 1, sum)

    #q <- stats::qt(w, df = df)
    #den <- mvtnorm::dmvt(q, delta = rep.int(0, d), sigma = P,
    #                     df = df, log = TRUE) +
    #apply(matrix(log(dBCS(x, mu, sigma, lambda, nu, gen[1])), ncol = d), 1, sum) -
    #apply(matrix(log(stats::dt(q, df = df)), ncol = d), 1, sum)

  }

  pmax(exp(den), .Machine$double.eps)

}

# Random generator
#' @rdname MBCSec
#' @export
rmbcsec <- function(n, param, P = NULL, d = 2L, df = 4,
                    copula = c("gaussian", "st", "cauchy", "dexponential"),
                    gen = "NO"){

  ### Reading the copula generating density
  copula <- match.arg(copula, c("gaussian", "st", "cauchy", "dexponential"))

  ### Default association matrix
  if (is.null(P)) P <- diag(d)

  ### Marginal parameters
  mu <- param$mu
  sigma <- param$sigma
  lambda <- param$lambda
  nu <- param$nu


  if (copula != "st"){
    x <- BCSgen(ell(copula)$gen)$p(ell(copula)$Mr(n, P))
    y <- matrix(apply(matrix(gen, ncol = 1), 1,
                      function(gen) qBCS(x, mu, sigma, lambda, nu, gen))[, 1], ncol = d)

    #x <- mvtnorm::rmvnorm(n, sigma = P)
    #y <- qBCS(stats::pnorm(x), mu, sigma, lambda, nu, gen)
  } else {
    x <- BCSgen(ell(copula)$gen)$p(ell(copula)$Mr(n, P, df), df)
    y <- matrix(apply(matrix(gen, ncol = 1), 1,
                      function(gen) qBCS(x, mu, sigma, lambda, nu, gen))[, 1], ncol = d)

    #x <- mvtnorm::rmvt(n, sigma = P, df = df)
    #y <- qBCS(stats::pt(x, df), mu, sigma, lambda, nu, gen)
  }

  y

}


